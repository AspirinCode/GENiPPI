import torch
import torch.nn as nn
from rdkit import Chem  # RDKit for handling chemical files
from moleculekit.molecule import Molecule  # Moleculekit for handling molecules
from moleculekit.tools.voxeldescriptors import getVoxelDescriptors, viewVoxelFeatures  # Tools for voxel descriptors
from moleculekit.tools.atomtyper import prepareProteinForAtomtyping  # For atom typing of proteins
from moleculekit.smallmol.smallmol import SmallMol  # Handling small molecules
from moleculekit.home import home  # Base path for moleculekit data
import moleculekit
import math
import numpy
import os
import shutil
import sys
from torchio.transforms import RandomAffine  # TorchIO library for affine transformations (augmentations)
import numpy as np  # NumPy for matrix and array operations

# Convert scientific notation in string format to numerical values
def str2num(string):
    try:
        temp = string.split('+')  # Split at the '+' sign
        base, index = temp[0], temp[1]  # Separate base and exponent
        base = base.split('e')[0]  # Handle scientific notation in 'e' format
        return float(base) * (10 ** int(index))  # Recalculate number from base and exponent
    except:
        return float(string)  # If it fails, return the float conversion of the string

# Main function to generate voxel descriptors
def generate_vox(ligand_name, output_path, tem_floder):
    # Step 1: Load the ligand file
    try:
        mol = SmallMol(ligand_name, force_reading=True)  # Load ligand using SmallMol (Moleculekit)
        center = mol.getCenter()  # Get center of mass of the ligand molecule
    except:
        print("Can not read file!")  # Error message if the ligand cannot be read
        return None

    # Step 2: Create a 'run.txt' file with voxelization parameters for external tool Multiwfn
    try:
        with open(tem_floder + "/run.txt", "w") as txt_file:
            txt_file.write("5\n")  # Example: Write parameters to 'run.txt' (custom input for Multiwfn)
            txt_file.write("1\n")
            txt_file.write("6\n")
            txt_file.write(str(center[0]) + "," + str(center[1]) + "," + str(center[2]) + "\n")  # Molecule center
            txt_file.write("35,35,35\n")  # Box size
            txt_file.write("66,66,66\n")  # Grid size
            txt_file.write("3\n")  # Example parameter for Multiwfn
    except:
        print("Can not create run file!")  # Error message if 'run.txt' cannot be created
        return None

    # Step 3: Run Multiwfn for electrostatic calculations and move the output file
    try:
        cmd = "Multiwfn " + ligand_name + " < " + tem_floder + "/run.txt > " + tem_floder + "/medinfo.txt > out.out"
        os.system(cmd)  # Run Multiwfn (external tool) with the parameters from 'run.txt'
        shutil.move("./output.txt", tem_floder + "/output_ligand.txt")  # Move the result to the temporary folder
    except:
        print("Can not run Multiwfn_ligand")  # Error message if Multiwfn fails
        return None

    # Step 4: Read the output file from Multiwfn and process the electrostatic density
    try:
        file = open(tem_floder + "/output_ligand.txt")  # Open output file generated by Multiwfn
        file_list = file.readlines()  # Read all lines from the file

        # Parse electrostatic density data and store in a 3D numpy array
        new_list = []
        for a_i in range(35):  # Iterate over voxel grid of size 35x35x35
            tem_list_x = []
            for b_i in range(35):
                tem_list_y = []
                for c_i in range(35):
                    number_tem = a_i * 35 * 35 + b_i * 35 + c_i  # Linear index in the file
                    tem = (file_list[number_tem]).split()[3]  # Extract the value from the file
                    tem = str2num(tem)  # Convert the value to numeric form
                    if tem == 0:
                        pass  # Ignore zero values
                    else:
                        tem = math.log10(tem)  # Take the logarithm of the value
                    tem_list_y.append(tem)  # Append to the y-dimension list
                tem_list_x.append(tem_list_y)  # Append to the x-dimension list
            new_list.append(tem_list_x)  # Build the 3D voxel array
        elect_np_ligand = numpy.array(new_list)  # Convert list to numpy array
    except:
        print("Can not create ligand_elect_den")  # Error message if the file cannot be processed
        return None

    # Step 5: Generate voxel descriptors for the ligand molecule
    try:
        mol = SmallMol(ligand_name, force_reading=True)  # Reload the ligand
        center = mol.getCenter()  # Get the molecular center again
        box = [35, 35, 35]  # Define the voxel box size (35x35x35)

        # Get voxel descriptors (8 molecular features such as hydrophobic, aromatic, etc.)
        mol_vox, mol_centers, mol_N = getVoxelDescriptors(mol, boxsize=box, voxelsize=1, buffer=0, center=center, validitychecks=False)

        # Reshape the voxel descriptor array to match the desired format
        mol_vox_t = mol_vox.transpose().reshape([1, mol_vox.shape[1], mol_N[0], mol_N[1], mol_N[2]])
    except:
        print("Can not Voxelization")  # Error message if voxel descriptors cannot be generated
        return None

    # Step 6: Combine electrostatic density with molecular voxel features
    finish_combine = numpy.squeeze(mol_vox_t)  # Remove extra dimension
    finish_combine = numpy.insert(finish_combine, 8, elect_np_ligand, axis=0)  # Add electrostatic density as an additional feature
    numpy.save(output_path, finish_combine)  # Save the combined array as a .npy file
    
    print("finish vox")  # Indicate completion
    return finish_combine  # Return the final combined array

# Main execution block
if __name__ == "__main__":
    ligand_name = "./1a30_ligand.pdb"  # Input PDB file of the ligand
    output_path = "./1a30.npy"  # Output path for saving the voxel descriptor numpy array
    tem_floder = "./tmp"  # Temporary folder for intermediate files

    # Generate voxel descriptors for the ligand
    finish_combine = generate_vox(ligand_name, output_path, tem_floder)

    print("voxelsize:", finish_combine.shape)  # Print the shape of the final voxel descriptor array

    # Convert the generated voxel data into a torch tensor for further processing
    file = torch.Tensor(np.squeeze(finish_combine))

    # Apply random affine transformation to the tensor using TorchIO
    trans = RandomAffine(scales=(1, 1), translation=5, isotropic=True, degrees=180)  # RandomAffine transformation (rotation, translation, scaling)
    tensor_trans = trans(file)  # Apply transformation to the tensor

    # Add an extra dimension to the transformed tensor
    tensor_trans2 = tensor_trans.unsqueeze(0)

    print(tensor_trans2.shape)  # Print the shape of the final transformed tensor
